// Code generated by gocc; DO NOT EDIT.

package parser

import (
	"gocc_babyduck/ast"
	"gocc_babyduck/token"
)

type (
	ProdTab      [numProductions]ProdTabEntry
	ProdTabEntry struct {
		String     string
		Id         string
		NTType     int
		Index      int
		NumSymbols int
		ReduceFunc func([]Attrib, interface{}) (Attrib, error)
	}
	Attrib interface {
	}
)

var productionsTable = ProdTab{
	ProdTabEntry{
		String: `S' : Programa	<<  >>`,
		Id:         "S'",
		NTType:     0,
		Index:      0,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return X[0], nil
		},
	},
	ProdTabEntry{
		String: `Programa : DECLARAR_PROGRAMA FUNCS_PROG main Body end	<<  >>`,
		Id:         "Programa",
		NTType:     1,
		Index:      1,
		NumSymbols: 5,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return X[0], nil
		},
	},
	ProdTabEntry{
		String: `DECLARAR_PROGRAMA : program id semicolon VARS_PROG	<< func() (Attrib, error){
        nombrePrograma := "program" + string(X[1].(*token.Token).Lit)

        //agregar "program xyz" a directorio de funciones
        _, err := ast.DeclararFuncion(
            nombrePrograma,             // Nombre de la función
            []ast.VariableInfo{},       // Parámetros vacios
            X[3].(*ast.HashMap),          // Variables locales
        )

        if err != nil {
            return nil, err
        }

        return nil, nil
    }() >>`,
		Id:         "DECLARAR_PROGRAMA",
		NTType:     2,
		Index:      2,
		NumSymbols: 4,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return func() (Attrib, error){
        nombrePrograma := "program" + string(X[1].(*token.Token).Lit)

        //agregar "program xyz" a directorio de funciones
        _, err := ast.DeclararFuncion(
            nombrePrograma,             // Nombre de la función
            []ast.VariableInfo{},       // Parámetros vacios
            X[3].(*ast.HashMap),          // Variables locales
        )

        if err != nil {
            return nil, err
        }

        return nil, nil
    }()
		},
	},
	ProdTabEntry{
		String: `VARS_PROG : VARS	<< func() (Attrib, error) {
        //lista de variables desde VARIABLES
        variables := X[0].([]ast.VariableInfo)

        globalVarsMap, err := ast.DeclaracionVar(variables)
        if err != nil {
            return nil, err
        }

        return globalVarsMap, nil
    }() >>`,
		Id:         "VARS_PROG",
		NTType:     3,
		Index:      3,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return func() (Attrib, error) {
        //lista de variables desde VARIABLES
        variables := X[0].([]ast.VariableInfo)

        globalVarsMap, err := ast.DeclaracionVar(variables)
        if err != nil {
            return nil, err
        }

        return globalVarsMap, nil
    }()
		},
	},
	ProdTabEntry{
		String: `VARS_PROG : empty	<< ast.NewHashMap(), nil >>`,
		Id:         "VARS_PROG",
		NTType:     3,
		Index:      4,
		NumSymbols: 0,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return ast.NewHashMap(), nil
		},
	},
	ProdTabEntry{
		String: `FUNCS_PROG : FUNCS FUNCS_PROG	<<  >>`,
		Id:         "FUNCS_PROG",
		NTType:     4,
		Index:      5,
		NumSymbols: 2,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return X[0], nil
		},
	},
	ProdTabEntry{
		String: `FUNCS_PROG : empty	<<  >>`,
		Id:         "FUNCS_PROG",
		NTType:     4,
		Index:      6,
		NumSymbols: 0,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return nil, nil
		},
	},
	ProdTabEntry{
		String: `VARS : var VARIABLES	<< X[1], nil >>`,
		Id:         "VARS",
		NTType:     5,
		Index:      7,
		NumSymbols: 2,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return X[1], nil
		},
	},
	ProdTabEntry{
		String: `VARIABLES : ID_LIST colon TYPE semicolon MAS_VARIABLES	<< func() (Attrib, error) {
        //crear la lista inicial con identificadores y tipo
        variables := []ast.VariableInfo{}
        
        for _, id := range X[0].([]string) {
            variables = append(variables, ast.VariableInfo{Name: id, Type: X[2].(string)})
        }

        //agregar las variables adicionales de MAS_VARIABLES
        additionalVars := X[4].([]ast.VariableInfo)
        variables = append(variables, additionalVars...)

        return variables, nil
   }() >>`,
		Id:         "VARIABLES",
		NTType:     6,
		Index:      8,
		NumSymbols: 5,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return func() (Attrib, error) {
        //crear la lista inicial con identificadores y tipo
        variables := []ast.VariableInfo{}
        
        for _, id := range X[0].([]string) {
            variables = append(variables, ast.VariableInfo{Name: id, Type: X[2].(string)})
        }

        //agregar las variables adicionales de MAS_VARIABLES
        additionalVars := X[4].([]ast.VariableInfo)
        variables = append(variables, additionalVars...)

        return variables, nil
   }()
		},
	},
	ProdTabEntry{
		String: `MAS_VARIABLES : VARIABLES	<< X[0], nil >>`,
		Id:         "MAS_VARIABLES",
		NTType:     7,
		Index:      9,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return X[0], nil
		},
	},
	ProdTabEntry{
		String: `MAS_VARIABLES : empty	<< []ast.VariableInfo{}, nil >>`,
		Id:         "MAS_VARIABLES",
		NTType:     7,
		Index:      10,
		NumSymbols: 0,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return []ast.VariableInfo{}, nil
		},
	},
	ProdTabEntry{
		String: `ID_LIST : id MAS_IDS	<< func() (Attrib, error){
        ids := append([]string{string(X[0].(*token.Token).Lit)}, X[1].([]string)...)
        return ids, nil
    }() >>`,
		Id:         "ID_LIST",
		NTType:     8,
		Index:      11,
		NumSymbols: 2,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return func() (Attrib, error){
        ids := append([]string{string(X[0].(*token.Token).Lit)}, X[1].([]string)...)
        return ids, nil
    }()
		},
	},
	ProdTabEntry{
		String: `MAS_IDS : comma ID_LIST	<< X[1], nil >>`,
		Id:         "MAS_IDS",
		NTType:     9,
		Index:      12,
		NumSymbols: 2,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return X[1], nil
		},
	},
	ProdTabEntry{
		String: `MAS_IDS : empty	<< []string{}, nil >>`,
		Id:         "MAS_IDS",
		NTType:     9,
		Index:      13,
		NumSymbols: 0,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return []string{}, nil
		},
	},
	ProdTabEntry{
		String: `TYPE : int	<< "int", nil >>`,
		Id:         "TYPE",
		NTType:     10,
		Index:      14,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return "int", nil
		},
	},
	ProdTabEntry{
		String: `TYPE : float	<< "float", nil >>`,
		Id:         "TYPE",
		NTType:     10,
		Index:      15,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return "float", nil
		},
	},
	ProdTabEntry{
		String: `FUNCS : FUNC_PRIMERA_PARTE lbraket VARS_FUNC CUERPO_FUNC	<< func() (Attrib, error){
            ast.CurrentFunction = nil
            return nil, nil
        }() >>`,
		Id:         "FUNCS",
		NTType:     11,
		Index:      16,
		NumSymbols: 4,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return func() (Attrib, error){
            ast.CurrentFunction = nil
            return nil, nil
        }()
		},
	},
	ProdTabEntry{
		String: `FUNC_PRIMERA_PARTE : void id lparen ID_LIST_PARAMS rparen	<< func() (Attrib, error){
            // Llamar a la función DeclararFuncion para agregar una nueva funcion
            fun, err := ast.DeclararFuncion(
            string(X[1].(*token.Token).Lit), // Nombre de la función
            X[3].([]ast.VariableInfo),      // Parámetros
            //X[6].(*ast.HashMap),            // Variables locales
            ast.NewHashMap(),                //tabla de variables temporalmente vacia
            )

            if err != nil {
                return nil, err
            }

            ast.CurrentFunction = fun

            return nil, nil
        }() >>`,
		Id:         "FUNC_PRIMERA_PARTE",
		NTType:     12,
		Index:      17,
		NumSymbols: 5,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return func() (Attrib, error){
            // Llamar a la función DeclararFuncion para agregar una nueva funcion
            fun, err := ast.DeclararFuncion(
            string(X[1].(*token.Token).Lit), // Nombre de la función
            X[3].([]ast.VariableInfo),      // Parámetros
            //X[6].(*ast.HashMap),            // Variables locales
            ast.NewHashMap(),                //tabla de variables temporalmente vacia
            )

            if err != nil {
                return nil, err
            }

            ast.CurrentFunction = fun

            return nil, nil
        }()
		},
	},
	ProdTabEntry{
		String: `CUERPO_FUNC : Body rbraket semicolon	<< X[0], nil >>`,
		Id:         "CUERPO_FUNC",
		NTType:     13,
		Index:      18,
		NumSymbols: 3,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return X[0], nil
		},
	},
	ProdTabEntry{
		String: `VARS_FUNC : VARS	<< func() (Attrib, error){
        //Obtener la lista de variables desde VARIABLES
        variables := X[0].([]ast.VariableInfo)

        // Registrar las variables en la tabla local de la función actual
        //localVarsMap, err := ast.DeclaracionVarLocal(variables)

        err := ast.InsertarVariableLocal(variables)

        if err != nil {
            return nil, err
        }

        //return localVarsMap, nil
        return nil, nil
    }() >>`,
		Id:         "VARS_FUNC",
		NTType:     14,
		Index:      19,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return func() (Attrib, error){
        //Obtener la lista de variables desde VARIABLES
        variables := X[0].([]ast.VariableInfo)

        // Registrar las variables en la tabla local de la función actual
        //localVarsMap, err := ast.DeclaracionVarLocal(variables)

        err := ast.InsertarVariableLocal(variables)

        if err != nil {
            return nil, err
        }

        //return localVarsMap, nil
        return nil, nil
    }()
		},
	},
	ProdTabEntry{
		String: `VARS_FUNC : empty	<< nil, nil >>`,
		Id:         "VARS_FUNC",
		NTType:     14,
		Index:      20,
		NumSymbols: 0,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return nil, nil
		},
	},
	ProdTabEntry{
		String: `ID_LIST_PARAMS : PARAMS MAS_PARAMS	<< func() (Attrib, error){
        params := append([]ast.VariableInfo{X[0].(ast.VariableInfo)}, X[1].([]ast.VariableInfo)...)
        return params, nil
    }() >>`,
		Id:         "ID_LIST_PARAMS",
		NTType:     15,
		Index:      21,
		NumSymbols: 2,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return func() (Attrib, error){
        params := append([]ast.VariableInfo{X[0].(ast.VariableInfo)}, X[1].([]ast.VariableInfo)...)
        return params, nil
    }()
		},
	},
	ProdTabEntry{
		String: `ID_LIST_PARAMS : empty	<< []ast.VariableInfo{}, nil >>`,
		Id:         "ID_LIST_PARAMS",
		NTType:     15,
		Index:      22,
		NumSymbols: 0,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return []ast.VariableInfo{}, nil
		},
	},
	ProdTabEntry{
		String: `MAS_PARAMS : comma PARAMS MAS_PARAMS	<< func() (Attrib, error){
        params := append([]ast.VariableInfo{X[1].(ast.VariableInfo)}, X[2].([]ast.VariableInfo)...)
        return params, nil
    }() >>`,
		Id:         "MAS_PARAMS",
		NTType:     16,
		Index:      23,
		NumSymbols: 3,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return func() (Attrib, error){
        params := append([]ast.VariableInfo{X[1].(ast.VariableInfo)}, X[2].([]ast.VariableInfo)...)
        return params, nil
    }()
		},
	},
	ProdTabEntry{
		String: `MAS_PARAMS : empty	<< []ast.VariableInfo{}, nil >>`,
		Id:         "MAS_PARAMS",
		NTType:     16,
		Index:      24,
		NumSymbols: 0,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return []ast.VariableInfo{}, nil
		},
	},
	ProdTabEntry{
		String: `PARAMS : id colon TYPE	<< func() (Attrib, error) {
        return ast.VariableInfo{Name: string(X[0].(*token.Token).Lit), Type: X[2].(string)}, nil
    }() >>`,
		Id:         "PARAMS",
		NTType:     17,
		Index:      25,
		NumSymbols: 3,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return func() (Attrib, error) {
        return ast.VariableInfo{Name: string(X[0].(*token.Token).Lit), Type: X[2].(string)}, nil
    }()
		},
	},
	ProdTabEntry{
		String: `Body : lbrace STATEMENT_PROG rbrace	<<  >>`,
		Id:         "Body",
		NTType:     18,
		Index:      26,
		NumSymbols: 3,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return X[0], nil
		},
	},
	ProdTabEntry{
		String: `STATEMENT_PROG : STATEMENT STATEMENT_PROG	<<  >>`,
		Id:         "STATEMENT_PROG",
		NTType:     19,
		Index:      27,
		NumSymbols: 2,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return X[0], nil
		},
	},
	ProdTabEntry{
		String: `STATEMENT_PROG : empty	<<  >>`,
		Id:         "STATEMENT_PROG",
		NTType:     19,
		Index:      28,
		NumSymbols: 0,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return nil, nil
		},
	},
	ProdTabEntry{
		String: `STATEMENT : ASSIGN	<<  >>`,
		Id:         "STATEMENT",
		NTType:     20,
		Index:      29,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return X[0], nil
		},
	},
	ProdTabEntry{
		String: `STATEMENT : IF	<<  >>`,
		Id:         "STATEMENT",
		NTType:     20,
		Index:      30,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return X[0], nil
		},
	},
	ProdTabEntry{
		String: `STATEMENT : CYCLE	<<  >>`,
		Id:         "STATEMENT",
		NTType:     20,
		Index:      31,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return X[0], nil
		},
	},
	ProdTabEntry{
		String: `STATEMENT : F_CALL	<<  >>`,
		Id:         "STATEMENT",
		NTType:     20,
		Index:      32,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return X[0], nil
		},
	},
	ProdTabEntry{
		String: `STATEMENT : PRINT	<<  >>`,
		Id:         "STATEMENT",
		NTType:     20,
		Index:      33,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return X[0], nil
		},
	},
	ProdTabEntry{
		String: `ASSIGN : id assign EXPRESION semicolon	<< func() (Attrib, error){
        //Verificacion de variable no declarada
        nombre := string(X[0].(*token.Token).Lit)

        varInfo, err := ast.BuscarVariable(nombre)
        if (err != nil){
            return nil, err
        }

        //asignacion
        err = ast.GenerateQuadrupleForAssign(varInfo)
        
        if err != nil {
            return nil, err
        }
        return nil, nil
    }() >>`,
		Id:         "ASSIGN",
		NTType:     21,
		Index:      34,
		NumSymbols: 4,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return func() (Attrib, error){
        //Verificacion de variable no declarada
        nombre := string(X[0].(*token.Token).Lit)

        varInfo, err := ast.BuscarVariable(nombre)
        if (err != nil){
            return nil, err
        }

        //asignacion
        err = ast.GenerateQuadrupleForAssign(varInfo)
        
        if err != nil {
            return nil, err
        }
        return nil, nil
    }()
		},
	},
	ProdTabEntry{
		String: `EXPRESION : EXP	<<  >>`,
		Id:         "EXPRESION",
		NTType:     22,
		Index:      35,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return X[0], nil
		},
	},
	ProdTabEntry{
		String: `EXPRESION : EXP OP_REL EXP	<< func() (Attrib, error){

        err := ast.GenerateQuadrupleForExp()
        
        if err != nil {
            return nil, err
        }
        return nil, nil
    }() >>`,
		Id:         "EXPRESION",
		NTType:     22,
		Index:      36,
		NumSymbols: 3,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return func() (Attrib, error){

        err := ast.GenerateQuadrupleForExp()
        
        if err != nil {
            return nil, err
        }
        return nil, nil
    }()
		},
	},
	ProdTabEntry{
		String: `OP_REL : gt	<< func() (Attrib, error){
        ast.Operadores.Push(">")
        return nil, nil
    }() >>`,
		Id:         "OP_REL",
		NTType:     23,
		Index:      37,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return func() (Attrib, error){
        ast.Operadores.Push(">")
        return nil, nil
    }()
		},
	},
	ProdTabEntry{
		String: `OP_REL : lt	<< func() (Attrib, error){
        ast.Operadores.Push("<")
        return nil, nil
    }() >>`,
		Id:         "OP_REL",
		NTType:     23,
		Index:      38,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return func() (Attrib, error){
        ast.Operadores.Push("<")
        return nil, nil
    }()
		},
	},
	ProdTabEntry{
		String: `OP_REL : neq	<< func() (Attrib, error){
        ast.Operadores.Push("!=")
        return nil, nil
    }() >>`,
		Id:         "OP_REL",
		NTType:     23,
		Index:      39,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return func() (Attrib, error){
        ast.Operadores.Push("!=")
        return nil, nil
    }()
		},
	},
	ProdTabEntry{
		String: `EXP : TERMINO	<< X[0], nil >>`,
		Id:         "EXP",
		NTType:     24,
		Index:      40,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return X[0], nil
		},
	},
	ProdTabEntry{
		String: `EXP : TERMINO PLUS_OP TERMINO	<< func() (Attrib, error){
        operador := ast.Operadores.Top()

        if(operador == "+" || operador == "-") {
            err := ast.GenerateQuadrupleForExp()
            if err != nil {
                return nil, err
            }
            return nil, nil
        }
        return nil, nil 
    }() >>`,
		Id:         "EXP",
		NTType:     24,
		Index:      41,
		NumSymbols: 3,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return func() (Attrib, error){
        operador := ast.Operadores.Top()

        if(operador == "+" || operador == "-") {
            err := ast.GenerateQuadrupleForExp()
            if err != nil {
                return nil, err
            }
            return nil, nil
        }
        return nil, nil 
    }()
		},
	},
	ProdTabEntry{
		String: `PLUS_OP : plus	<< func() (Attrib, error){
        ast.Operadores.Push("+")
        return nil, nil
    }() >>`,
		Id:         "PLUS_OP",
		NTType:     25,
		Index:      42,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return func() (Attrib, error){
        ast.Operadores.Push("+")
        return nil, nil
    }()
		},
	},
	ProdTabEntry{
		String: `EXP : TERMINO MINUS_OP TERMINO	<< func() (Attrib, error){
        operador := ast.Operadores.Top()

        if(operador == "+" || operador == "-") {
            err := ast.GenerateQuadrupleForExp()
            if err != nil {
                return nil, err
            }
            return nil, nil
        }
        return nil, nil 
    }() >>`,
		Id:         "EXP",
		NTType:     24,
		Index:      43,
		NumSymbols: 3,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return func() (Attrib, error){
        operador := ast.Operadores.Top()

        if(operador == "+" || operador == "-") {
            err := ast.GenerateQuadrupleForExp()
            if err != nil {
                return nil, err
            }
            return nil, nil
        }
        return nil, nil 
    }()
		},
	},
	ProdTabEntry{
		String: `MINUS_OP : minus	<< func() (Attrib, error){
        ast.Operadores.Push("-")
        return nil, nil
    }() >>`,
		Id:         "MINUS_OP",
		NTType:     26,
		Index:      44,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return func() (Attrib, error){
        ast.Operadores.Push("-")
        return nil, nil
    }()
		},
	},
	ProdTabEntry{
		String: `TERMINO : FACTOR	<< X[0], nil >>`,
		Id:         "TERMINO",
		NTType:     27,
		Index:      45,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return X[0], nil
		},
	},
	ProdTabEntry{
		String: `TERMINO : FACTOR MULT_OP FACTOR	<< func() (Attrib, error){
        operador := ast.Operadores.Top()

        if(operador == "*" || operador == "/") {
            err := ast.GenerateQuadrupleForExp()
            if err != nil {
                return nil, err
            }
            return nil, nil
        }
        return nil, nil 
    }() >>`,
		Id:         "TERMINO",
		NTType:     27,
		Index:      46,
		NumSymbols: 3,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return func() (Attrib, error){
        operador := ast.Operadores.Top()

        if(operador == "*" || operador == "/") {
            err := ast.GenerateQuadrupleForExp()
            if err != nil {
                return nil, err
            }
            return nil, nil
        }
        return nil, nil 
    }()
		},
	},
	ProdTabEntry{
		String: `MULT_OP : multiply	<< func() (Attrib, error){
        ast.Operadores.Push("*")
        return nil, nil
    }() >>`,
		Id:         "MULT_OP",
		NTType:     28,
		Index:      47,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return func() (Attrib, error){
        ast.Operadores.Push("*")
        return nil, nil
    }()
		},
	},
	ProdTabEntry{
		String: `TERMINO : FACTOR DIV_OP FACTOR	<< func() (Attrib, error){
        operador := ast.Operadores.Top()

        if(operador == "*" || operador == "/") {
            err := ast.GenerateQuadrupleForExp()
            if err != nil {
                return nil, err
            }
            return nil, nil
        }
        return nil, nil 
    }() >>`,
		Id:         "TERMINO",
		NTType:     27,
		Index:      48,
		NumSymbols: 3,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return func() (Attrib, error){
        operador := ast.Operadores.Top()

        if(operador == "*" || operador == "/") {
            err := ast.GenerateQuadrupleForExp()
            if err != nil {
                return nil, err
            }
            return nil, nil
        }
        return nil, nil 
    }()
		},
	},
	ProdTabEntry{
		String: `DIV_OP : divide	<< func() (Attrib, error){
        ast.Operadores.Push("/")
        return nil, nil
    }() >>`,
		Id:         "DIV_OP",
		NTType:     29,
		Index:      49,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return func() (Attrib, error){
        ast.Operadores.Push("/")
        return nil, nil
    }()
		},
	},
	ProdTabEntry{
		String: `FACTOR : FONDO_FALSO EXPRESION rparen	<< func() (Attrib, error){

        for !ast.Operadores.IsEmpty(){

            top := ast.Operadores.Top()
            if top == "(" {
                ast.Operadores.Pop()
                break
            }
            err := ast.GenerateQuadrupleForExp()
            if err != nil {
                return nil, err
            }
        }
        return nil, nil
    }() >>`,
		Id:         "FACTOR",
		NTType:     30,
		Index:      50,
		NumSymbols: 3,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return func() (Attrib, error){

        for !ast.Operadores.IsEmpty(){

            top := ast.Operadores.Top()
            if top == "(" {
                ast.Operadores.Pop()
                break
            }
            err := ast.GenerateQuadrupleForExp()
            if err != nil {
                return nil, err
            }
        }
        return nil, nil
    }()
		},
	},
	ProdTabEntry{
		String: `FONDO_FALSO : lparen	<< func() (Attrib, error){
        ast.Operadores.Push("(")
        return nil, nil
    }() >>`,
		Id:         "FONDO_FALSO",
		NTType:     31,
		Index:      51,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return func() (Attrib, error){
        ast.Operadores.Push("(")
        return nil, nil
    }()
		},
	},
	ProdTabEntry{
		String: `FACTOR : FACTOR_OPERADOR ID_CTE	<< X[1],nil >>`,
		Id:         "FACTOR",
		NTType:     30,
		Index:      52,
		NumSymbols: 2,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return X[1],nil
		},
	},
	ProdTabEntry{
		String: `FACTOR_OPERADOR : PLUS_OP	<< X[0], nil >>`,
		Id:         "FACTOR_OPERADOR",
		NTType:     32,
		Index:      53,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return X[0], nil
		},
	},
	ProdTabEntry{
		String: `FACTOR_OPERADOR : MINUS_OP	<< X[0], nil >>`,
		Id:         "FACTOR_OPERADOR",
		NTType:     32,
		Index:      54,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return X[0], nil
		},
	},
	ProdTabEntry{
		String: `FACTOR_OPERADOR : empty	<<  >>`,
		Id:         "FACTOR_OPERADOR",
		NTType:     32,
		Index:      55,
		NumSymbols: 0,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return nil, nil
		},
	},
	ProdTabEntry{
		String: `ID_CTE : id	<< func() (Attrib, error){
        //Verificacion de variable no declarada
        nombre := string(X[0].(*token.Token).Lit)

        //Buscar variable
        varInfo, error := ast.BuscarVariable(nombre)
        if (error != nil){
            return nil, error
        }

        //Agregar a pila de Operandos
        //ast.Operandos.Push(varInfo.Name)
        ast.Operandos.Push(varInfo.Address)
        ast.Tipos.Push(varInfo.Type)
        
        return nil, nil
    }() >>`,
		Id:         "ID_CTE",
		NTType:     33,
		Index:      56,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return func() (Attrib, error){
        //Verificacion de variable no declarada
        nombre := string(X[0].(*token.Token).Lit)

        //Buscar variable
        varInfo, error := ast.BuscarVariable(nombre)
        if (error != nil){
            return nil, error
        }

        //Agregar a pila de Operandos
        //ast.Operandos.Push(varInfo.Name)
        ast.Operandos.Push(varInfo.Address)
        ast.Tipos.Push(varInfo.Type)
        
        return nil, nil
    }()
		},
	},
	ProdTabEntry{
		String: `ID_CTE : CTE	<< func() (Attrib, error){
        cte := X[0].([]string) // Obtener la lista devuelta por CTE
        //valor := cte[0]
        tipo := cte[1]

        direccion := ast.Prog_MemoryManager.GetConstVarMem(tipo)

        //ast.Operandos.Push(valor)
        ast.Operandos.Push(direccion)
        ast.Tipos.Push(tipo)

        return nil, nil
    }() >>`,
		Id:         "ID_CTE",
		NTType:     33,
		Index:      57,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return func() (Attrib, error){
        cte := X[0].([]string) // Obtener la lista devuelta por CTE
        //valor := cte[0]
        tipo := cte[1]

        direccion := ast.Prog_MemoryManager.GetConstVarMem(tipo)

        //ast.Operandos.Push(valor)
        ast.Operandos.Push(direccion)
        ast.Tipos.Push(tipo)

        return nil, nil
    }()
		},
	},
	ProdTabEntry{
		String: `CTE : cte_int	<< func() (Attrib, error) {
        valor := string(X[0].(*token.Token).Lit)
        return []string{valor, "int"}, nil
    }() >>`,
		Id:         "CTE",
		NTType:     34,
		Index:      58,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return func() (Attrib, error) {
        valor := string(X[0].(*token.Token).Lit)
        return []string{valor, "int"}, nil
    }()
		},
	},
	ProdTabEntry{
		String: `CTE : cte_float	<< func() (Attrib, error) {
        valor := string(X[0].(*token.Token).Lit)
        return []string{valor, "float"}, nil
    }() >>`,
		Id:         "CTE",
		NTType:     34,
		Index:      59,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return func() (Attrib, error) {
        valor := string(X[0].(*token.Token).Lit)
        return []string{valor, "float"}, nil
    }()
		},
	},
	ProdTabEntry{
		String: `IF : if CONDITION Body ELSE_BODY semicolon	<< func() (Attrib, error){
        hayElse := X[3].(bool)

        if(hayElse){
            goto_Jump := ast.PJumps.Pop()   //indice del goto que salta al else
            falseJump := ast.PJumps.Pop()

            //Llenar GOTO: saltar el else
            quadGoto := ast.Cuadruplos.GetItem(goto_Jump) 
            quadGoto.Res = ast.Cuadruplos.Size() 
            ast.Cuadruplos.Update(goto_Jump, quadGoto) 

            //Llenar el GOTOF: apunta al inicio del else
            quadGoToF := ast.Cuadruplos.GetItem(falseJump)
            quadGoToF.Res = goto_Jump + 1   //salta al quad despues del GOTO (que es el else)
            ast.Cuadruplos.Update(falseJump, quadGoToF)
        } else {
            // Solo Pop del GOTOF (condición)
            falseJump := ast.PJumps.Pop()
            quadGoToF := ast.Cuadruplos.GetItem(falseJump)
            quadGoToF.Res = ast.Cuadruplos.Size()
            ast.Cuadruplos.Update(falseJump, quadGoToF)
        }
        
        return nil, nil
    }() >>`,
		Id:         "IF",
		NTType:     35,
		Index:      60,
		NumSymbols: 5,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return func() (Attrib, error){
        hayElse := X[3].(bool)

        if(hayElse){
            goto_Jump := ast.PJumps.Pop()   //indice del goto que salta al else
            falseJump := ast.PJumps.Pop()

            //Llenar GOTO: saltar el else
            quadGoto := ast.Cuadruplos.GetItem(goto_Jump) 
            quadGoto.Res = ast.Cuadruplos.Size() 
            ast.Cuadruplos.Update(goto_Jump, quadGoto) 

            //Llenar el GOTOF: apunta al inicio del else
            quadGoToF := ast.Cuadruplos.GetItem(falseJump)
            quadGoToF.Res = goto_Jump + 1   //salta al quad despues del GOTO (que es el else)
            ast.Cuadruplos.Update(falseJump, quadGoToF)
        } else {
            // Solo Pop del GOTOF (condición)
            falseJump := ast.PJumps.Pop()
            quadGoToF := ast.Cuadruplos.GetItem(falseJump)
            quadGoToF.Res = ast.Cuadruplos.Size()
            ast.Cuadruplos.Update(falseJump, quadGoToF)
        }
        
        return nil, nil
    }()
		},
	},
	ProdTabEntry{
		String: `CONDITION : lparen EXPRESION rparen	<< func() (Attrib, error){
        //validar condiction
        cond := ast.Operandos.Pop()
        tipo := ast.Tipos.Pop()

        err := ast.VerificarCondicion(tipo)
        if(err != nil){
            return nil, err
        }

        //Generar cuadruplo GoToF
        quad := ast.NewQuadruple("GOTOF", cond, 0, 0)
        ast.Cuadruplos.Enqueue(quad)

        //Guardar el indice del cuadruplo para regresar a llenarlo
        ast.PJumps.Push(ast.Cuadruplos.Size() - 1)

        return nil, nil
    }() >>`,
		Id:         "CONDITION",
		NTType:     36,
		Index:      61,
		NumSymbols: 3,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return func() (Attrib, error){
        //validar condiction
        cond := ast.Operandos.Pop()
        tipo := ast.Tipos.Pop()

        err := ast.VerificarCondicion(tipo)
        if(err != nil){
            return nil, err
        }

        //Generar cuadruplo GoToF
        quad := ast.NewQuadruple("GOTOF", cond, 0, 0)
        ast.Cuadruplos.Enqueue(quad)

        //Guardar el indice del cuadruplo para regresar a llenarlo
        ast.PJumps.Push(ast.Cuadruplos.Size() - 1)

        return nil, nil
    }()
		},
	},
	ProdTabEntry{
		String: `ELSE_BODY : else ELSE_JUMP Body	<< func() (Attrib, error){
        return true, nil
    }() >>`,
		Id:         "ELSE_BODY",
		NTType:     37,
		Index:      62,
		NumSymbols: 3,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return func() (Attrib, error){
        return true, nil
    }()
		},
	},
	ProdTabEntry{
		String: `ELSE_BODY : empty	<< func() (Attrib, error){
        return false, nil
    }() >>`,
		Id:         "ELSE_BODY",
		NTType:     37,
		Index:      63,
		NumSymbols: 0,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return func() (Attrib, error){
        return false, nil
    }()
		},
	},
	ProdTabEntry{
		String: `ELSE_JUMP : empty	<< func() (Attrib, error){
        quad := ast.NewQuadruple("GOTO", 0, 0, 0)
        ast.Cuadruplos.Enqueue(quad)
        ast.PJumps.Push(ast.Cuadruplos.Size() - 1) //size - 1 agarra el quad GOTO que se acaba de hacer
        return nil, nil
    }() >>`,
		Id:         "ELSE_JUMP",
		NTType:     38,
		Index:      64,
		NumSymbols: 0,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return func() (Attrib, error){
        quad := ast.NewQuadruple("GOTO", 0, 0, 0)
        ast.Cuadruplos.Enqueue(quad)
        ast.PJumps.Push(ast.Cuadruplos.Size() - 1) //size - 1 agarra el quad GOTO que se acaba de hacer
        return nil, nil
    }()
		},
	},
	ProdTabEntry{
		String: `CYCLE : WHILE_START CONDITION do Body WHILE_END semicolon	<<  >>`,
		Id:         "CYCLE",
		NTType:     39,
		Index:      65,
		NumSymbols: 6,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return X[0], nil
		},
	},
	ProdTabEntry{
		String: `WHILE_START : while	<< func() (Attrib, error){
        //guarda la posicion de inicio del ciclo
        ast.PJumps.Push(ast.Cuadruplos.Size())
        return nil, nil
    }() >>`,
		Id:         "WHILE_START",
		NTType:     40,
		Index:      66,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return func() (Attrib, error){
        //guarda la posicion de inicio del ciclo
        ast.PJumps.Push(ast.Cuadruplos.Size())
        return nil, nil
    }()
		},
	},
	ProdTabEntry{
		String: `WHILE_END : empty	<< func()(Attrib, error){
        returnJump := ast.PJumps.Pop() - 1
        falseJump := ast.PJumps.Pop() +1

        //GOTO para regresar al inicio del ciclo
        quadGoTo := ast.NewQuadruple("GOTO", 0, 0, returnJump)
        ast.Cuadruplos.Enqueue(quadGoTo)

        //BackPatch al GOTOF para salir del ciclo
        quadGoToF := ast.Cuadruplos.GetItem(falseJump)
        quadGoToF.Res = ast.Cuadruplos.Size()
        ast.Cuadruplos.Update(falseJump, quadGoToF)

        return nil, nil
    }() >>`,
		Id:         "WHILE_END",
		NTType:     41,
		Index:      67,
		NumSymbols: 0,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return func()(Attrib, error){
        returnJump := ast.PJumps.Pop() - 1
        falseJump := ast.PJumps.Pop() +1

        //GOTO para regresar al inicio del ciclo
        quadGoTo := ast.NewQuadruple("GOTO", 0, 0, returnJump)
        ast.Cuadruplos.Enqueue(quadGoTo)

        //BackPatch al GOTOF para salir del ciclo
        quadGoToF := ast.Cuadruplos.GetItem(falseJump)
        quadGoToF.Res = ast.Cuadruplos.Size()
        ast.Cuadruplos.Update(falseJump, quadGoToF)

        return nil, nil
    }()
		},
	},
	ProdTabEntry{
		String: `F_CALL : id lparen EXPRESION_STATEMENT rparen semicolon	<<  >>`,
		Id:         "F_CALL",
		NTType:     42,
		Index:      68,
		NumSymbols: 5,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return X[0], nil
		},
	},
	ProdTabEntry{
		String: `EXPRESION_STATEMENT : EXPRESION MAS_EXPRESIONES	<<  >>`,
		Id:         "EXPRESION_STATEMENT",
		NTType:     43,
		Index:      69,
		NumSymbols: 2,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return X[0], nil
		},
	},
	ProdTabEntry{
		String: `EXPRESION_STATEMENT : empty	<<  >>`,
		Id:         "EXPRESION_STATEMENT",
		NTType:     43,
		Index:      70,
		NumSymbols: 0,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return nil, nil
		},
	},
	ProdTabEntry{
		String: `MAS_EXPRESIONES : comma EXPRESION MAS_EXPRESIONES	<<  >>`,
		Id:         "MAS_EXPRESIONES",
		NTType:     44,
		Index:      71,
		NumSymbols: 3,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return X[0], nil
		},
	},
	ProdTabEntry{
		String: `MAS_EXPRESIONES : empty	<<  >>`,
		Id:         "MAS_EXPRESIONES",
		NTType:     44,
		Index:      72,
		NumSymbols: 0,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return nil, nil
		},
	},
	ProdTabEntry{
		String: `PRINT : print lparen LISTA_PRINT rparen semicolon	<< func() (Attrib, error){

        lista := X[2].([]int)

        for dir := range lista {
            err := ast.GenerateQuadrupleForPrint(lista[dir])
            if (err !=nil){
                return nil, err
            }
        } 
        return nil, nil
    }() >>`,
		Id:         "PRINT",
		NTType:     45,
		Index:      73,
		NumSymbols: 5,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return func() (Attrib, error){

        lista := X[2].([]int)

        for dir := range lista {
            err := ast.GenerateQuadrupleForPrint(lista[dir])
            if (err !=nil){
                return nil, err
            }
        } 
        return nil, nil
    }()
		},
	},
	ProdTabEntry{
		String: `LISTA_PRINT : EXPRESION_PRINT EXPRESIONES_PRINT	<< func() (Attrib, error){
        // Obtener la primera expresión
        primera := X[0].(int)

        // Obtener la lista de expresiones adicionales
        adicionales := X[1].([]int)

        // Combinar en una sola lista
        lista := append([]int{primera}, adicionales...)

        return lista, nil
    }() >>`,
		Id:         "LISTA_PRINT",
		NTType:     46,
		Index:      74,
		NumSymbols: 2,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return func() (Attrib, error){
        // Obtener la primera expresión
        primera := X[0].(int)

        // Obtener la lista de expresiones adicionales
        adicionales := X[1].([]int)

        // Combinar en una sola lista
        lista := append([]int{primera}, adicionales...)

        return lista, nil
    }()
		},
	},
	ProdTabEntry{
		String: `EXPRESION_PRINT : EXPRESION	<< func() (Attrib, error){

        //if ast.Operandos.IsEmpty() {
        //    return nil, error
        //}

        // Hacer Pop del resultado de la pila de operandos
        direccion := ast.Operandos.Pop()
        ast.Tipos.Pop()  // descartar el tipo

        return direccion, nil
    }() >>`,
		Id:         "EXPRESION_PRINT",
		NTType:     47,
		Index:      75,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return func() (Attrib, error){

        //if ast.Operandos.IsEmpty() {
        //    return nil, error
        //}

        // Hacer Pop del resultado de la pila de operandos
        direccion := ast.Operandos.Pop()
        ast.Tipos.Pop()  // descartar el tipo

        return direccion, nil
    }()
		},
	},
	ProdTabEntry{
		String: `EXPRESION_PRINT : cte_string	<< func() (Attrib, error){
       // valor := string(X[0].(*token.Token).Lit)
        //ast.Operandos.Push(valor)

        direccion := ast.Prog_MemoryManager.GetStringConstMem()
        return direccion,nil
    }() >>`,
		Id:         "EXPRESION_PRINT",
		NTType:     47,
		Index:      76,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return func() (Attrib, error){
       // valor := string(X[0].(*token.Token).Lit)
        //ast.Operandos.Push(valor)

        direccion := ast.Prog_MemoryManager.GetStringConstMem()
        return direccion,nil
    }()
		},
	},
	ProdTabEntry{
		String: `EXPRESIONES_PRINT : comma EXPRESION_PRINT EXPRESIONES_PRINT	<< func() (Attrib, error) {
        // Agregar la expresión actual al inicio de la lista
        valor := X[1].(int)
        lista := X[2].([]int)

        lista = append([]int{valor}, lista...)

        return lista, nil
    }() >>`,
		Id:         "EXPRESIONES_PRINT",
		NTType:     48,
		Index:      77,
		NumSymbols: 3,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return func() (Attrib, error) {
        // Agregar la expresión actual al inicio de la lista
        valor := X[1].(int)
        lista := X[2].([]int)

        lista = append([]int{valor}, lista...)

        return lista, nil
    }()
		},
	},
	ProdTabEntry{
		String: `EXPRESIONES_PRINT : empty	<< func() (Attrib, error) {
        return []int{}, nil
    }() >>`,
		Id:         "EXPRESIONES_PRINT",
		NTType:     48,
		Index:      78,
		NumSymbols: 0,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return func() (Attrib, error) {
        return []int{}, nil
    }()
		},
	},
}
