// Code generated by gocc; DO NOT EDIT.

package parser

import (
	"gocc_babyduck/ast"
	"gocc_babyduck/token"
)

type (
	ProdTab      [numProductions]ProdTabEntry
	ProdTabEntry struct {
		String     string
		Id         string
		NTType     int
		Index      int
		NumSymbols int
		ReduceFunc func([]Attrib, interface{}) (Attrib, error)
	}
	Attrib interface {
	}
)

var productionsTable = ProdTab{
	ProdTabEntry{
		String: `S' : Programa	<<  >>`,
		Id:         "S'",
		NTType:     0,
		Index:      0,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return X[0], nil
		},
	},
	ProdTabEntry{
		String: `Programa : DECLARA_PROG FUNCS_PROG main Body end	<<  >>`,
		Id:         "Programa",
		NTType:     1,
		Index:      1,
		NumSymbols: 5,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return X[0], nil
		},
	},
	ProdTabEntry{
		String: `DECLARA_PROG : program id semicolon VARS_PROG	<< func() (Attrib, error){
        nombre_prog := string(X[1].(*token.Token).Lit)

        //agregar prog a FunctionDir
        _, err := ast.Declare_Function(
            nombre_prog,                // nombre
            []ast.VariableInfo{},       // sin params
            X[3].(*ast.HashMap),          // vars globales
        )

        if err != nil {
            return nil, err
        }

        //agregar tabla vacia de temps y de ctes

        return nil, nil
    }() >>`,
		Id:         "DECLARA_PROG",
		NTType:     2,
		Index:      2,
		NumSymbols: 4,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return func() (Attrib, error){
        nombre_prog := string(X[1].(*token.Token).Lit)

        //agregar prog a FunctionDir
        _, err := ast.Declare_Function(
            nombre_prog,                // nombre
            []ast.VariableInfo{},       // sin params
            X[3].(*ast.HashMap),          // vars globales
        )

        if err != nil {
            return nil, err
        }

        //agregar tabla vacia de temps y de ctes

        return nil, nil
    }()
		},
	},
	ProdTabEntry{
		String: `VARS_PROG : VARS	<< func() (Attrib, error) {
        variables := X[0].([]ast.VariableInfo)    //slice de variables (name,type)

        variables_globales, err := ast.Declare_GlobalVars(variables)
        if err != nil {
            return nil, err
        }

        return variables_globales, nil
    }() >>`,
		Id:         "VARS_PROG",
		NTType:     3,
		Index:      3,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return func() (Attrib, error) {
        variables := X[0].([]ast.VariableInfo)    //slice de variables (name,type)

        variables_globales, err := ast.Declare_GlobalVars(variables)
        if err != nil {
            return nil, err
        }

        return variables_globales, nil
    }()
		},
	},
	ProdTabEntry{
		String: `VARS_PROG : empty	<< ast.NewHashMap(), nil >>`,
		Id:         "VARS_PROG",
		NTType:     3,
		Index:      4,
		NumSymbols: 0,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return ast.NewHashMap(), nil
		},
	},
	ProdTabEntry{
		String: `FUNCS_PROG : FUNCS FUNCS_PROG	<<  >>`,
		Id:         "FUNCS_PROG",
		NTType:     4,
		Index:      5,
		NumSymbols: 2,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return X[0], nil
		},
	},
	ProdTabEntry{
		String: `FUNCS_PROG : empty	<<  >>`,
		Id:         "FUNCS_PROG",
		NTType:     4,
		Index:      6,
		NumSymbols: 0,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return nil, nil
		},
	},
	ProdTabEntry{
		String: `VARS : var VARIABLES	<< X[1], nil >>`,
		Id:         "VARS",
		NTType:     5,
		Index:      7,
		NumSymbols: 2,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return X[1], nil
		},
	},
	ProdTabEntry{
		String: `VARIABLES : ID_LIST colon TYPE semicolon MAS_VARIABLES	<< func() (Attrib, error) {
        //crear SLICE (no mapa) de vars
        id_list := X[0].([]string)
        type_vars := X[2].(string)

        variables := ast.Create_VarList(id_list, type_vars)

        //agregar las variables adicionales
        additionalVars := X[4].([]ast.VariableInfo)
        variables = append(variables, additionalVars...)

        return variables, nil
   }() >>`,
		Id:         "VARIABLES",
		NTType:     6,
		Index:      8,
		NumSymbols: 5,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return func() (Attrib, error) {
        //crear SLICE (no mapa) de vars
        id_list := X[0].([]string)
        type_vars := X[2].(string)

        variables := ast.Create_VarList(id_list, type_vars)

        //agregar las variables adicionales
        additionalVars := X[4].([]ast.VariableInfo)
        variables = append(variables, additionalVars...)

        return variables, nil
   }()
		},
	},
	ProdTabEntry{
		String: `MAS_VARIABLES : VARIABLES	<< X[0], nil >>`,
		Id:         "MAS_VARIABLES",
		NTType:     7,
		Index:      9,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return X[0], nil
		},
	},
	ProdTabEntry{
		String: `MAS_VARIABLES : empty	<< []ast.VariableInfo{}, nil >>`,
		Id:         "MAS_VARIABLES",
		NTType:     7,
		Index:      10,
		NumSymbols: 0,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return []ast.VariableInfo{}, nil
		},
	},
	ProdTabEntry{
		String: `ID_LIST : id MAS_IDS	<< func() (Attrib, error){
        id := string(X[0].(*token.Token).Lit)
        mas_ids := X[1].([]string)

        id_list := append([]string{id}, mas_ids...)

        return id_list, nil
    }() >>`,
		Id:         "ID_LIST",
		NTType:     8,
		Index:      11,
		NumSymbols: 2,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return func() (Attrib, error){
        id := string(X[0].(*token.Token).Lit)
        mas_ids := X[1].([]string)

        id_list := append([]string{id}, mas_ids...)

        return id_list, nil
    }()
		},
	},
	ProdTabEntry{
		String: `MAS_IDS : comma ID_LIST	<< X[1], nil >>`,
		Id:         "MAS_IDS",
		NTType:     9,
		Index:      12,
		NumSymbols: 2,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return X[1], nil
		},
	},
	ProdTabEntry{
		String: `MAS_IDS : empty	<< []string{}, nil >>`,
		Id:         "MAS_IDS",
		NTType:     9,
		Index:      13,
		NumSymbols: 0,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return []string{}, nil
		},
	},
	ProdTabEntry{
		String: `TYPE : int	<< "int", nil >>`,
		Id:         "TYPE",
		NTType:     10,
		Index:      14,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return "int", nil
		},
	},
	ProdTabEntry{
		String: `TYPE : float	<< "float", nil >>`,
		Id:         "TYPE",
		NTType:     10,
		Index:      15,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return "float", nil
		},
	},
	ProdTabEntry{
		String: `FUNCS : DECLARA_FUNC lbraket VARS_FUNC Body rbraket semicolon	<< func() (Attrib, error){
            ast.CurrentFunction = nil
            return nil, nil
        }() >>`,
		Id:         "FUNCS",
		NTType:     11,
		Index:      16,
		NumSymbols: 6,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return func() (Attrib, error){
            ast.CurrentFunction = nil
            return nil, nil
        }()
		},
	},
	ProdTabEntry{
		String: `DECLARA_FUNC : void id lparen HAY_PARAMS rparen	<< func() (Attrib, error){
            nombre_fun := string(X[1].(*token.Token).Lit)
            parametros := X[3].([]ast.VariableInfo)
            local_varMap := ast.NewHashMap()

            _, err := ast.Declare_Function(
                nombre_fun,
                parametros,
                local_varMap,                //tabla de variables vacia
            )

            if err != nil {
                return nil, err
            }

            //ast.CurrentFunction = funcion

            return nil, nil
        }() >>`,
		Id:         "DECLARA_FUNC",
		NTType:     12,
		Index:      17,
		NumSymbols: 5,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return func() (Attrib, error){
            nombre_fun := string(X[1].(*token.Token).Lit)
            parametros := X[3].([]ast.VariableInfo)
            local_varMap := ast.NewHashMap()

            _, err := ast.Declare_Function(
                nombre_fun,
                parametros,
                local_varMap,                //tabla de variables vacia
            )

            if err != nil {
                return nil, err
            }

            //ast.CurrentFunction = funcion

            return nil, nil
        }()
		},
	},
	ProdTabEntry{
		String: `HAY_PARAMS : PARAMETROS	<< X[0], nil >>`,
		Id:         "HAY_PARAMS",
		NTType:     13,
		Index:      18,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return X[0], nil
		},
	},
	ProdTabEntry{
		String: `HAY_PARAMS : empty	<< []ast.VariableInfo{}, nil >>`,
		Id:         "HAY_PARAMS",
		NTType:     13,
		Index:      19,
		NumSymbols: 0,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return []ast.VariableInfo{}, nil
		},
	},
	ProdTabEntry{
		String: `PARAMETROS : PARAM MAS_PARAMS	<< func() (Attrib, error){
        param := X[0].(ast.VariableInfo)
        mas_params := X[1].([]ast.VariableInfo)

        parametros := append([]ast.VariableInfo {param}, mas_params...)

        return parametros, nil
    }() >>`,
		Id:         "PARAMETROS",
		NTType:     14,
		Index:      20,
		NumSymbols: 2,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return func() (Attrib, error){
        param := X[0].(ast.VariableInfo)
        mas_params := X[1].([]ast.VariableInfo)

        parametros := append([]ast.VariableInfo {param}, mas_params...)

        return parametros, nil
    }()
		},
	},
	ProdTabEntry{
		String: `PARAM : id colon TYPE	<< func() (Attrib, error) {
        parametro := ast.VariableInfo {
            Name: string(X[0].(*token.Token).Lit),    //nombre
            Type: X[2].(string),                       //tipo
                                                    //memoria?
        }
        return parametro, nil
    }() >>`,
		Id:         "PARAM",
		NTType:     15,
		Index:      21,
		NumSymbols: 3,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return func() (Attrib, error) {
        parametro := ast.VariableInfo {
            Name: string(X[0].(*token.Token).Lit),    //nombre
            Type: X[2].(string),                       //tipo
                                                    //memoria?
        }
        return parametro, nil
    }()
		},
	},
	ProdTabEntry{
		String: `MAS_PARAMS : comma PARAMETROS	<< X[1], nil >>`,
		Id:         "MAS_PARAMS",
		NTType:     16,
		Index:      22,
		NumSymbols: 2,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return X[1], nil
		},
	},
	ProdTabEntry{
		String: `MAS_PARAMS : empty	<< []ast.VariableInfo{}, nil >>`,
		Id:         "MAS_PARAMS",
		NTType:     16,
		Index:      23,
		NumSymbols: 0,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return []ast.VariableInfo{}, nil
		},
	},
	ProdTabEntry{
		String: `VARS_FUNC : VARS	<< func() (Attrib, error){

        parametros := ast.CurrentFunction.Parameters
        variables := X[0].([]ast.VariableInfo)

        //lista de params y vars locales
        variables_locales := append(parametros, variables...)

        err := ast.Declare_LocalVars(variables_locales)

        if err != nil {
            return nil, err
        }

        return nil, nil
    }() >>`,
		Id:         "VARS_FUNC",
		NTType:     17,
		Index:      24,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return func() (Attrib, error){

        parametros := ast.CurrentFunction.Parameters
        variables := X[0].([]ast.VariableInfo)

        //lista de params y vars locales
        variables_locales := append(parametros, variables...)

        err := ast.Declare_LocalVars(variables_locales)

        if err != nil {
            return nil, err
        }

        return nil, nil
    }()
		},
	},
	ProdTabEntry{
		String: `VARS_FUNC : empty	<< nil, nil >>`,
		Id:         "VARS_FUNC",
		NTType:     17,
		Index:      25,
		NumSymbols: 0,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return nil, nil
		},
	},
	ProdTabEntry{
		String: `Body : lbrace STATEMENT_PROG rbrace	<<  >>`,
		Id:         "Body",
		NTType:     18,
		Index:      26,
		NumSymbols: 3,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return X[0], nil
		},
	},
	ProdTabEntry{
		String: `STATEMENT_PROG : STATEMENT STATEMENT_PROG	<<  >>`,
		Id:         "STATEMENT_PROG",
		NTType:     19,
		Index:      27,
		NumSymbols: 2,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return X[0], nil
		},
	},
	ProdTabEntry{
		String: `STATEMENT_PROG : empty	<<  >>`,
		Id:         "STATEMENT_PROG",
		NTType:     19,
		Index:      28,
		NumSymbols: 0,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return nil, nil
		},
	},
	ProdTabEntry{
		String: `STATEMENT : ASSIGN	<<  >>`,
		Id:         "STATEMENT",
		NTType:     20,
		Index:      29,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return X[0], nil
		},
	},
	ProdTabEntry{
		String: `STATEMENT : IF	<<  >>`,
		Id:         "STATEMENT",
		NTType:     20,
		Index:      30,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return X[0], nil
		},
	},
	ProdTabEntry{
		String: `STATEMENT : CYCLE	<<  >>`,
		Id:         "STATEMENT",
		NTType:     20,
		Index:      31,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return X[0], nil
		},
	},
	ProdTabEntry{
		String: `STATEMENT : F_CALL	<<  >>`,
		Id:         "STATEMENT",
		NTType:     20,
		Index:      32,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return X[0], nil
		},
	},
	ProdTabEntry{
		String: `STATEMENT : PRINT	<<  >>`,
		Id:         "STATEMENT",
		NTType:     20,
		Index:      33,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return X[0], nil
		},
	},
	ProdTabEntry{
		String: `ASSIGN : id assign EXPRESION semicolon	<< func() (Attrib, error){
        //Verificacion de variable no declarada
        nombre := string(X[0].(*token.Token).Lit)

        varInfo, err := ast.BuscarVariable(nombre)
        if (err != nil){
            return nil, err
        }

        //asignacion
        err = ast.GenerateQuadrupleForAssign(varInfo)
        
        if err != nil {
            return nil, err
        }
        return nil, nil
    }() >>`,
		Id:         "ASSIGN",
		NTType:     21,
		Index:      34,
		NumSymbols: 4,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return func() (Attrib, error){
        //Verificacion de variable no declarada
        nombre := string(X[0].(*token.Token).Lit)

        varInfo, err := ast.BuscarVariable(nombre)
        if (err != nil){
            return nil, err
        }

        //asignacion
        err = ast.GenerateQuadrupleForAssign(varInfo)
        
        if err != nil {
            return nil, err
        }
        return nil, nil
    }()
		},
	},
	ProdTabEntry{
		String: `EXPRESION : EXP	<<  >>`,
		Id:         "EXPRESION",
		NTType:     22,
		Index:      35,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return X[0], nil
		},
	},
	ProdTabEntry{
		String: `EXPRESION : EXP OP_REL EXP	<< func() (Attrib, error){

        //checar si hay operadores-operandos
        err := ast.IsStackEmpty()
        if err != nil {
            return nil, err
        }

        err = ast.GenerateQuadrupleForExp()
        if err != nil {
            return nil, err
        }
        return nil, nil
    }() >>`,
		Id:         "EXPRESION",
		NTType:     22,
		Index:      36,
		NumSymbols: 3,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return func() (Attrib, error){

        //checar si hay operadores-operandos
        err := ast.IsStackEmpty()
        if err != nil {
            return nil, err
        }

        err = ast.GenerateQuadrupleForExp()
        if err != nil {
            return nil, err
        }
        return nil, nil
    }()
		},
	},
	ProdTabEntry{
		String: `OP_REL : gt	<< func() (Attrib, error){
        ast.Operadores.Push(">")
        return nil, nil
    }() >>`,
		Id:         "OP_REL",
		NTType:     23,
		Index:      37,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return func() (Attrib, error){
        ast.Operadores.Push(">")
        return nil, nil
    }()
		},
	},
	ProdTabEntry{
		String: `OP_REL : lt	<< func() (Attrib, error){
        ast.Operadores.Push("<")
        return nil, nil
    }() >>`,
		Id:         "OP_REL",
		NTType:     23,
		Index:      38,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return func() (Attrib, error){
        ast.Operadores.Push("<")
        return nil, nil
    }()
		},
	},
	ProdTabEntry{
		String: `OP_REL : neq	<< func() (Attrib, error){
        ast.Operadores.Push("!=")
        return nil, nil
    }() >>`,
		Id:         "OP_REL",
		NTType:     23,
		Index:      39,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return func() (Attrib, error){
        ast.Operadores.Push("!=")
        return nil, nil
    }()
		},
	},
	ProdTabEntry{
		String: `EXP : TERMINO	<<  >>`,
		Id:         "EXP",
		NTType:     24,
		Index:      40,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return X[0], nil
		},
	},
	ProdTabEntry{
		String: `EXP : TERMINO PLUS_MINUS TERMINO	<< func() (Attrib, error){

        //checar si hay operadores-operandos
        err := ast.IsStackEmpty()
        if err != nil {
            return nil, err
        }

        operador := ast.Operadores.Top()

        if(operador == "+" || operador == "-") {
            err := ast.GenerateQuadrupleForExp()
            if err != nil {
                return nil, err
            }
            return nil, nil
        }
        return nil, nil 
    }() >>`,
		Id:         "EXP",
		NTType:     24,
		Index:      41,
		NumSymbols: 3,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return func() (Attrib, error){

        //checar si hay operadores-operandos
        err := ast.IsStackEmpty()
        if err != nil {
            return nil, err
        }

        operador := ast.Operadores.Top()

        if(operador == "+" || operador == "-") {
            err := ast.GenerateQuadrupleForExp()
            if err != nil {
                return nil, err
            }
            return nil, nil
        }
        return nil, nil 
    }()
		},
	},
	ProdTabEntry{
		String: `PLUS_MINUS : plus	<< func() (Attrib, error){
        ast.Operadores.Push("+")
        return nil, nil
    }() >>`,
		Id:         "PLUS_MINUS",
		NTType:     25,
		Index:      42,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return func() (Attrib, error){
        ast.Operadores.Push("+")
        return nil, nil
    }()
		},
	},
	ProdTabEntry{
		String: `PLUS_MINUS : minus	<< func() (Attrib, error){
        ast.Operadores.Push("-")
        return nil, nil
    }() >>`,
		Id:         "PLUS_MINUS",
		NTType:     25,
		Index:      43,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return func() (Attrib, error){
        ast.Operadores.Push("-")
        return nil, nil
    }()
		},
	},
	ProdTabEntry{
		String: `TERMINO : FACTOR	<<  >>`,
		Id:         "TERMINO",
		NTType:     26,
		Index:      44,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return X[0], nil
		},
	},
	ProdTabEntry{
		String: `TERMINO : FACTOR MULT_DIV FACTOR	<< func() (Attrib, error){

        //checar si hay operadores-operandos
        err := ast.IsStackEmpty()
        if err != nil {
            return nil, err
        }

        operador := ast.Operadores.Top()

        if(operador == "*" || operador == "/") {
            err := ast.GenerateQuadrupleForExp()
            if err != nil {
                return nil, err
            }
            return nil, nil
        }
        return nil, nil 
    }() >>`,
		Id:         "TERMINO",
		NTType:     26,
		Index:      45,
		NumSymbols: 3,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return func() (Attrib, error){

        //checar si hay operadores-operandos
        err := ast.IsStackEmpty()
        if err != nil {
            return nil, err
        }

        operador := ast.Operadores.Top()

        if(operador == "*" || operador == "/") {
            err := ast.GenerateQuadrupleForExp()
            if err != nil {
                return nil, err
            }
            return nil, nil
        }
        return nil, nil 
    }()
		},
	},
	ProdTabEntry{
		String: `MULT_DIV : multiply	<< func() (Attrib, error){
        ast.Operadores.Push("*")
        return nil, nil
    }() >>`,
		Id:         "MULT_DIV",
		NTType:     27,
		Index:      46,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return func() (Attrib, error){
        ast.Operadores.Push("*")
        return nil, nil
    }()
		},
	},
	ProdTabEntry{
		String: `MULT_DIV : divide	<< func() (Attrib, error){
        ast.Operadores.Push("/")
        return nil, nil
    }() >>`,
		Id:         "MULT_DIV",
		NTType:     27,
		Index:      47,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return func() (Attrib, error){
        ast.Operadores.Push("/")
        return nil, nil
    }()
		},
	},
	ProdTabEntry{
		String: `FACTOR : FONDO_FALSO EXPRESION rparen	<< func() (Attrib, error){

        //checar si hay operadores-operandos
        err := ast.IsStackEmpty()
        if err != nil {
            return nil, err
        }

        operador := ast.Operadores.Top()

        for( operador != "(" ){
            err := ast.GenerateQuadrupleForExp()
            if err != nil {
                return nil, err
            }
        }
        ast.Operadores.Pop()
        
        return nil, nil
    }() >>`,
		Id:         "FACTOR",
		NTType:     28,
		Index:      48,
		NumSymbols: 3,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return func() (Attrib, error){

        //checar si hay operadores-operandos
        err := ast.IsStackEmpty()
        if err != nil {
            return nil, err
        }

        operador := ast.Operadores.Top()

        for( operador != "(" ){
            err := ast.GenerateQuadrupleForExp()
            if err != nil {
                return nil, err
            }
        }
        ast.Operadores.Pop()
        
        return nil, nil
    }()
		},
	},
	ProdTabEntry{
		String: `FONDO_FALSO : lparen	<< func() (Attrib, error){
        ast.Operadores.Push("(")
        return nil, nil
    }() >>`,
		Id:         "FONDO_FALSO",
		NTType:     29,
		Index:      49,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return func() (Attrib, error){
        ast.Operadores.Push("(")
        return nil, nil
    }()
		},
	},
	ProdTabEntry{
		String: `FACTOR : FACTOR_OPERADOR ID_CTE	<<  >>`,
		Id:         "FACTOR",
		NTType:     28,
		Index:      50,
		NumSymbols: 2,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return X[0], nil
		},
	},
	ProdTabEntry{
		String: `FACTOR_OPERADOR : PLUS_MINUS	<<  >>`,
		Id:         "FACTOR_OPERADOR",
		NTType:     30,
		Index:      51,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return X[0], nil
		},
	},
	ProdTabEntry{
		String: `FACTOR_OPERADOR : empty	<<  >>`,
		Id:         "FACTOR_OPERADOR",
		NTType:     30,
		Index:      52,
		NumSymbols: 0,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return nil, nil
		},
	},
	ProdTabEntry{
		String: `ID_CTE : id	<< func() (Attrib, error){

        nombre_var := string(X[0].(*token.Token).Lit)

        //verificacion de variable
        varInfo, error := ast.BuscarVariable(nombre_var)
        if (error != nil){
            return nil, error
        }

        //si si existe, agregarla a los stacks
        ast.Operandos.Push(varInfo.Address)
        ast.Tipos.Push(varInfo.Type)
        
        return nil, nil
    }() >>`,
		Id:         "ID_CTE",
		NTType:     31,
		Index:      53,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return func() (Attrib, error){

        nombre_var := string(X[0].(*token.Token).Lit)

        //verificacion de variable
        varInfo, error := ast.BuscarVariable(nombre_var)
        if (error != nil){
            return nil, error
        }

        //si si existe, agregarla a los stacks
        ast.Operandos.Push(varInfo.Address)
        ast.Tipos.Push(varInfo.Type)
        
        return nil, nil
    }()
		},
	},
	ProdTabEntry{
		String: `ID_CTE : CTE	<< func() (Attrib, error){
        cte := X[0].([]string) //slice con info de la cte
        valor := cte[0]
        tipo := cte[1]

        direccion := ast.Declare_Constant(valor, tipo)

        ast.Operandos.Push(direccion)
        ast.Tipos.Push(tipo)

        return nil, nil
    }() >>`,
		Id:         "ID_CTE",
		NTType:     31,
		Index:      54,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return func() (Attrib, error){
        cte := X[0].([]string) //slice con info de la cte
        valor := cte[0]
        tipo := cte[1]

        direccion := ast.Declare_Constant(valor, tipo)

        ast.Operandos.Push(direccion)
        ast.Tipos.Push(tipo)

        return nil, nil
    }()
		},
	},
	ProdTabEntry{
		String: `CTE : cte_int	<< func() (Attrib, error) {
        valor := string(X[0].(*token.Token).Lit)
        cte_int := []string {valor, "int"}
        return cte_int, nil
    }() >>`,
		Id:         "CTE",
		NTType:     32,
		Index:      55,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return func() (Attrib, error) {
        valor := string(X[0].(*token.Token).Lit)
        cte_int := []string {valor, "int"}
        return cte_int, nil
    }()
		},
	},
	ProdTabEntry{
		String: `CTE : cte_float	<< func() (Attrib, error) {
        valor := string(X[0].(*token.Token).Lit)
        cte_float := []string {valor, "float"}
        return cte_float, nil
    }() >>`,
		Id:         "CTE",
		NTType:     32,
		Index:      56,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return func() (Attrib, error) {
        valor := string(X[0].(*token.Token).Lit)
        cte_float := []string {valor, "float"}
        return cte_float, nil
    }()
		},
	},
	ProdTabEntry{
		String: `IF : if CONDITION Body ELSE_BODY semicolon	<< func() (Attrib, error){
        hayElse := X[3].(bool)

        if(hayElse){

            //llenar el GOTO
            quad_GOTO := ast.PJumps.Pop()
            value_GOTO := ast.Cuadruplos.Size()
            err := ast.Fill_QuadJumps(quad_GOTO, value_GOTO)

            if(err != nil){
                return nil, err
            }

            //llenar el GOTOF
            quad_GOTOF := ast.PJumps.Pop()
            value_GOTOF := quad_GOTO + 1
            err = ast.Fill_QuadJumps(quad_GOTOF, value_GOTOF)

            if(err!=nil){
                return nil, err
            }

        } else {
            //si no hay else, llenar solo GOTOF
            quad_GOTOF := ast.PJumps.Pop()
            value_GOTOF := ast.Cuadruplos.Size()
            err := ast.Fill_QuadJumps(quad_GOTOF, value_GOTOF)

            if(err!=nil){
                return nil, err
            }
        }
        return nil, nil
    }() >>`,
		Id:         "IF",
		NTType:     33,
		Index:      57,
		NumSymbols: 5,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return func() (Attrib, error){
        hayElse := X[3].(bool)

        if(hayElse){

            //llenar el GOTO
            quad_GOTO := ast.PJumps.Pop()
            value_GOTO := ast.Cuadruplos.Size()
            err := ast.Fill_QuadJumps(quad_GOTO, value_GOTO)

            if(err != nil){
                return nil, err
            }

            //llenar el GOTOF
            quad_GOTOF := ast.PJumps.Pop()
            value_GOTOF := quad_GOTO + 1
            err = ast.Fill_QuadJumps(quad_GOTOF, value_GOTOF)

            if(err!=nil){
                return nil, err
            }

        } else {
            //si no hay else, llenar solo GOTOF
            quad_GOTOF := ast.PJumps.Pop()
            value_GOTOF := ast.Cuadruplos.Size()
            err := ast.Fill_QuadJumps(quad_GOTOF, value_GOTOF)

            if(err!=nil){
                return nil, err
            }
        }
        return nil, nil
    }()
		},
	},
	ProdTabEntry{
		String: `CONDITION : lparen EXPRESION rparen	<< func() (Attrib, error){
        err := ast.GenerateQuad_GOTOF()

        if(err != nil){
            return nil, err
        }
        
        return nil, nil
    }() >>`,
		Id:         "CONDITION",
		NTType:     34,
		Index:      58,
		NumSymbols: 3,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return func() (Attrib, error){
        err := ast.GenerateQuad_GOTOF()

        if(err != nil){
            return nil, err
        }
        
        return nil, nil
    }()
		},
	},
	ProdTabEntry{
		String: `ELSE_BODY : else ELSE_JUMP Body	<< func() (Attrib, error){
        return true, nil
    }() >>`,
		Id:         "ELSE_BODY",
		NTType:     35,
		Index:      59,
		NumSymbols: 3,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return func() (Attrib, error){
        return true, nil
    }()
		},
	},
	ProdTabEntry{
		String: `ELSE_BODY : empty	<< func() (Attrib, error){
        return false, nil
    }() >>`,
		Id:         "ELSE_BODY",
		NTType:     35,
		Index:      60,
		NumSymbols: 0,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return func() (Attrib, error){
        return false, nil
    }()
		},
	},
	ProdTabEntry{
		String: `ELSE_JUMP : empty	<< func() (Attrib, error){
        err := ast.GenerateQuad_GOTO()

        if(err != nil){
            return nil, err
        }
        
        return nil, nil
    }() >>`,
		Id:         "ELSE_JUMP",
		NTType:     36,
		Index:      61,
		NumSymbols: 0,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return func() (Attrib, error){
        err := ast.GenerateQuad_GOTO()

        if(err != nil){
            return nil, err
        }
        
        return nil, nil
    }()
		},
	},
	ProdTabEntry{
		String: `CYCLE : WHILE_START CONDITION do Body WHILE_END semicolon	<<  >>`,
		Id:         "CYCLE",
		NTType:     37,
		Index:      62,
		NumSymbols: 6,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return X[0], nil
		},
	},
	ProdTabEntry{
		String: `WHILE_START : while	<< func() (Attrib, error){
        ast.PJumps.Push(ast.Cuadruplos.Size())  //quad de lo que hace la condicion
        return nil, nil
    }() >>`,
		Id:         "WHILE_START",
		NTType:     38,
		Index:      63,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return func() (Attrib, error){
        ast.PJumps.Push(ast.Cuadruplos.Size())  //quad de lo que hace la condicion
        return nil, nil
    }()
		},
	},
	ProdTabEntry{
		String: `WHILE_END : empty	<< func()(Attrib, error){
        quad_GOTOF := ast.PJumps.Pop()
        quad_whileSTART := ast.PJumps.Pop()

        //llenar GOTO (que regresa al while)
        op_code := ast.CodigoNum_Operador["GOTO"]
        quadGO_TO := ast.NewQuadruple(op_code, 0, 0, quad_whileSTART)
        ast.Cuadruplos.Enqueue(quadGO_TO)

        //llenar GOTOF
        value_GOTOF := ast.Cuadruplos.Size()
        err := ast.Fill_QuadJumps(quad_GOTOF, value_GOTOF)

        if(err!=nil){
            return nil, err
        }

        return nil, nil
    }() >>`,
		Id:         "WHILE_END",
		NTType:     39,
		Index:      64,
		NumSymbols: 0,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return func()(Attrib, error){
        quad_GOTOF := ast.PJumps.Pop()
        quad_whileSTART := ast.PJumps.Pop()

        //llenar GOTO (que regresa al while)
        op_code := ast.CodigoNum_Operador["GOTO"]
        quadGO_TO := ast.NewQuadruple(op_code, 0, 0, quad_whileSTART)
        ast.Cuadruplos.Enqueue(quadGO_TO)

        //llenar GOTOF
        value_GOTOF := ast.Cuadruplos.Size()
        err := ast.Fill_QuadJumps(quad_GOTOF, value_GOTOF)

        if(err!=nil){
            return nil, err
        }

        return nil, nil
    }()
		},
	},
	ProdTabEntry{
		String: `F_CALL : FUNC_CALL_START lparen EXPRESION_STATEMENT rparen semicolon	<<  >>`,
		Id:         "F_CALL",
		NTType:     40,
		Index:      65,
		NumSymbols: 5,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return X[0], nil
		},
	},
	ProdTabEntry{
		String: `FUNC_CALL_START : id	<<  >>`,
		Id:         "FUNC_CALL_START",
		NTType:     41,
		Index:      66,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return X[0], nil
		},
	},
	ProdTabEntry{
		String: `EXPRESION_STATEMENT : EXPRESION MAS_EXPRESIONES	<<  >>`,
		Id:         "EXPRESION_STATEMENT",
		NTType:     42,
		Index:      67,
		NumSymbols: 2,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return X[0], nil
		},
	},
	ProdTabEntry{
		String: `EXPRESION_STATEMENT : empty	<<  >>`,
		Id:         "EXPRESION_STATEMENT",
		NTType:     42,
		Index:      68,
		NumSymbols: 0,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return nil, nil
		},
	},
	ProdTabEntry{
		String: `MAS_EXPRESIONES : comma EXPRESION MAS_EXPRESIONES	<<  >>`,
		Id:         "MAS_EXPRESIONES",
		NTType:     43,
		Index:      69,
		NumSymbols: 3,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return X[0], nil
		},
	},
	ProdTabEntry{
		String: `MAS_EXPRESIONES : empty	<<  >>`,
		Id:         "MAS_EXPRESIONES",
		NTType:     43,
		Index:      70,
		NumSymbols: 0,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return nil, nil
		},
	},
	ProdTabEntry{
		String: `PRINT : print lparen LISTA_PRINT rparen semicolon	<< func() (Attrib, error){

        lista := X[2].([]int)

        for dir := range lista {
            err := ast.GenerateQuadrupleForPrint(lista[dir])
            if (err !=nil){
                return nil, err
            }
        } 
        return nil, nil
    }() >>`,
		Id:         "PRINT",
		NTType:     44,
		Index:      71,
		NumSymbols: 5,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return func() (Attrib, error){

        lista := X[2].([]int)

        for dir := range lista {
            err := ast.GenerateQuadrupleForPrint(lista[dir])
            if (err !=nil){
                return nil, err
            }
        } 
        return nil, nil
    }()
		},
	},
	ProdTabEntry{
		String: `LISTA_PRINT : EXPRESION_PRINT EXPRESIONES_PRINT	<< func() (Attrib, error){
        // Obtener la primera expresión
        primera := X[0].(int)

        // Obtener la lista de expresiones adicionales
        adicionales := X[1].([]int)

        // Combinar en una sola lista
        lista := append([]int{primera}, adicionales...)

        return lista, nil
    }() >>`,
		Id:         "LISTA_PRINT",
		NTType:     45,
		Index:      72,
		NumSymbols: 2,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return func() (Attrib, error){
        // Obtener la primera expresión
        primera := X[0].(int)

        // Obtener la lista de expresiones adicionales
        adicionales := X[1].([]int)

        // Combinar en una sola lista
        lista := append([]int{primera}, adicionales...)

        return lista, nil
    }()
		},
	},
	ProdTabEntry{
		String: `EXPRESION_PRINT : EXPRESION	<< func() (Attrib, error){

        //if ast.Operandos.IsEmpty() {
        //    return nil, error
        //}

        // Hacer Pop del resultado de la pila de operandos
        direccion := ast.Operandos.Pop()
        ast.Tipos.Pop()  // descartar el tipo

        return direccion, nil
    }() >>`,
		Id:         "EXPRESION_PRINT",
		NTType:     46,
		Index:      73,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return func() (Attrib, error){

        //if ast.Operandos.IsEmpty() {
        //    return nil, error
        //}

        // Hacer Pop del resultado de la pila de operandos
        direccion := ast.Operandos.Pop()
        ast.Tipos.Pop()  // descartar el tipo

        return direccion, nil
    }()
		},
	},
	ProdTabEntry{
		String: `EXPRESION_PRINT : cte_string	<< func() (Attrib, error){
        valor := string(X[0].(*token.Token).Lit)

        direccion := ast.Declare_Constant(valor,"string")
        return direccion,nil
    }() >>`,
		Id:         "EXPRESION_PRINT",
		NTType:     46,
		Index:      74,
		NumSymbols: 1,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return func() (Attrib, error){
        valor := string(X[0].(*token.Token).Lit)

        direccion := ast.Declare_Constant(valor,"string")
        return direccion,nil
    }()
		},
	},
	ProdTabEntry{
		String: `EXPRESIONES_PRINT : comma EXPRESION_PRINT EXPRESIONES_PRINT	<< func() (Attrib, error) {
        // Agregar la expresión actual al inicio de la lista
        valor := X[1].(int)
        lista := X[2].([]int)

        lista = append([]int{valor}, lista...)

        return lista, nil
    }() >>`,
		Id:         "EXPRESIONES_PRINT",
		NTType:     47,
		Index:      75,
		NumSymbols: 3,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return func() (Attrib, error) {
        // Agregar la expresión actual al inicio de la lista
        valor := X[1].(int)
        lista := X[2].([]int)

        lista = append([]int{valor}, lista...)

        return lista, nil
    }()
		},
	},
	ProdTabEntry{
		String: `EXPRESIONES_PRINT : empty	<< func() (Attrib, error) {
        return []int{}, nil
    }() >>`,
		Id:         "EXPRESIONES_PRINT",
		NTType:     47,
		Index:      76,
		NumSymbols: 0,
		ReduceFunc: func(X []Attrib, C interface{}) (Attrib, error) {
			return func() (Attrib, error) {
        return []int{}, nil
    }()
		},
	},
}
